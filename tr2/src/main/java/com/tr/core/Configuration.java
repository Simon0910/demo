/*
 * MDES for Merchants
 * The MDES APIs are designed as RPC style stateless web services where each API endpoint represents an operation to be performed.  All request and response payloads are sent in the JSON (JavaScript Object Notation) data-interchange format. Each endpoint in the API specifies the HTTP Method used to access it. All strings in request and response objects are to be UTF-8 encoded.  Each API URI includes the major and minor version of API that it conforms to.  This will allow multiple concurrent versions of the API to be deployed simultaneously. <br> __Authentication__ Mastercard uses OAuth 1.0a with body hash extension for authenticating the API clients. This requires every request that you send to  Mastercard to be signed with an RSA private key. A private-public RSA key pair must be generated consisting of: <br> 1 . A private key for the OAuth signature for API requests. It is recommended to keep the private key in a password-protected or hardware keystore. <br> 2. A public key is shared with Mastercard during the project setup process through either a certificate signing request (CSR) or the API Key Generator. Mastercard will use the public key to verify the OAuth signature that is provided on every API call.<br>  An OAUTH1.0a signer library is available on [GitHub](https://github.com/Mastercard/oauth1-signer-java) <br>  __Encryption__<br>  All communications between Issuer web service and the Mastercard gateway is encrypted using TLS. <br> __Additional Encryption of Sensitive Data__ In addition to the OAuth authentication, when using MDES Digital Enablement Service, any PCI sensitive and all account holder Personally Identifiable Information (PII) data must be encrypted. This requirement applies to the API fields containing encryptedData. Sensitive data is encrypted using a symmetric session (one-time-use) key. The symmetric session key is then wrapped with an RSA Public Key supplied by Mastercard during API setup phase (the Customer Encryption Key). <br>  Java Client Encryption Library available on [GitHub](https://github.com/Mastercard/client-encryption-java)
 *
 * The version of the OpenAPI document: 1.2.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.tr.core;

import com.tr.core.auth.Authentication;
import com.tr.core.utils.SSLUtil;
import okhttp3.*;
import okhttp3.logging.HttpLoggingInterceptor;
import okio.BufferedSink;
import okio.Okio;
import org.threeten.bp.format.DateTimeFormatter;

import javax.net.ssl.*;
import java.io.*;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.text.DateFormat;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// @org.springframework.context.annotation.Configuration
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2019-08-16T09:54:27.990+01:00[Europe/London]")
public class Configuration {
    private static boolean isEnable = false;
    private static String defaultKeyStorePath;
    private static String defaultKeyStorePassword;
    private static String defaultSslCaCertPath;

    private static Environment defaultEnvironment = Environment.SANDBOX;
    private static Map<String, ResourceConfigInterface> registeredInstances = new HashMap<String, ResourceConfigInterface>();

    private static boolean debugging = false;
    private String tempFolderPath = null;

    private Map<String, Authentication> authentications;

    private DateFormat dateFormat;
    private DateFormat datetimeFormat;
    private boolean lenientDatetimeFormat;
    private int dateLength;

    private InputStream sslCaCert;
    private boolean verifyingSsl;
    private KeyManager[] keyManagers;

    private static OkHttpClient httpClient;
    private static JSON json;

    private static HttpLoggingInterceptor loggingInterceptor;

    // @Value("${master.ssl.enable}")
    public void setIsEnable(boolean isEnable) {
        Configuration.isEnable = isEnable;
    }
    //
    // @Value("${master.ssl.keystore}")
    public void setDefaultKeyStorePath(String defaultKeyStorePath) {
        Configuration.defaultKeyStorePath = defaultKeyStorePath;
    }
    //
    // @Value("${master.ssl.keystore.pass}")
    public void setDefaultKeyStorePassword(String defaultKeyStorePassword) {
        Configuration.defaultKeyStorePassword = defaultKeyStorePassword;
    }
    //
    // @Value("${master.ssl.sslcacert}")
    public void setDefaultSslCaCertPath(String defaultSslCaCertPath) {
        Configuration.defaultSslCaCertPath = defaultSslCaCertPath;
    }

    /**
     * Basic constructor for Configuration
     */
    public Configuration() {
        init();

        // Setup authentications (key: authentication name, value: authentication).
        // Prevent the authentications from being modified.
        authentications = Collections.unmodifiableMap(authentications);
    }

    private void init() {
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder.addNetworkInterceptor(getProgressInterceptor());
        // TR DEFAULT SETTING
        builder.connectTimeout(60, TimeUnit.SECONDS);
        builder.readTimeout(100, TimeUnit.SECONDS);
        builder.writeTimeout(60, TimeUnit.SECONDS);
        // CONNECTION POOL 32, WAIT TIME 5
        builder.connectionPool(new ConnectionPool(32, 5, TimeUnit.MINUTES));
        httpClient = builder.build();

        verifyingSsl = true;

        json = new JSON();

        authentications = new HashMap<String, Authentication>();
    }


    /**
     * Get HTTP client
     *
     * @return An instance of OkHttpClient
     */
    public static OkHttpClient getHttpClient() {
        return httpClient;
    }


    /**
     * True if isVerifyingSsl flag is on
     *
     * @return True if isVerifySsl flag is on
     */
    public boolean isVerifyingSsl() {
        return verifyingSsl;
    }

    /**
     * Configure whether to verify certificate and hostname when making https requests.
     * Default to true.
     * NOTE: Do NOT set to false in production code, otherwise you would face multiple types of cryptographic attacks.
     *
     * @param verifyingSsl True to verify TLS/SSL connection
     * @return Configuration
     */
    public Configuration setVerifyingSsl(boolean verifyingSsl) {
        this.verifyingSsl = verifyingSsl;
        applySslSettings();
        return this;
    }

    /**
     * Get SSL CA cert.
     *
     * @return Input stream to the SSL CA cert
     */
    public InputStream getSslCaCert() {
        return sslCaCert;
    }

    /**
     * Configure the CA certificate to be trusted when making https requests.
     * Use null to reset to default.
     *
     * @param sslCaCert input stream for SSL CA cert
     * @return Configuration
     */
    public Configuration setSslCaCert(InputStream sslCaCert) {
        this.sslCaCert = sslCaCert;
        applySslSettings();
        return this;
    }


    public KeyManager[] getKeyManagers() {
        return keyManagers;
    }

    /**
     * Configure client keys to use for authorization in an SSL session.
     * Use null to reset to default.
     *
     * @param managers The KeyManagers to use
     * @return Configuration
     */
    public Configuration setKeyManagers(KeyManager[] managers) {
        this.keyManagers = managers;
        applySslSettings();
        return this;
    }

    private void loadkeyManagers(String keystorePath, String KeyStorePassword) throws CertificateException {
        try {
            KeyStore keyStore = SSLUtil.getKeyStore(keystorePath, "jks", KeyStorePassword);
            keyManagers = SSLUtil.getKeyManagers(keyStore, KeyStorePassword);
        } catch (Exception e) {
            e.printStackTrace();
            throw new CertificateException();
        }
    }

    private void loadSslCaCert(String sslCaCertPath) throws FileNotFoundException {
        sslCaCert = new FileInputStream(new File(sslCaCertPath));
    }

    // @PostConstruct
    // private void enableSSL() {
    public void enableSSL() {
        try {
            if (isEnable) {
                loadkeyManagers(defaultKeyStorePath, defaultKeyStorePassword);
                // loadSslCaCert(defaultSslCaCertPath);
                applySslSettings();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public DateFormat getDateFormat() {
        return dateFormat;
    }

    public Configuration setDateFormat(DateFormat dateFormat) {
        json.setDateFormat(dateFormat);
        return this;
    }

    public Configuration setSqlDateFormat(DateFormat dateFormat) {
        json.setSqlDateFormat(dateFormat);
        return this;
    }

    public Configuration setOffsetDateTimeFormat(DateTimeFormatter dateFormat) {
        json.setOffsetDateTimeFormat(dateFormat);
        return this;
    }

    public Configuration setLocalDateFormat(DateTimeFormatter dateFormat) {
        json.setLocalDateFormat(dateFormat);
        return this;
    }

    public Configuration setLenientOnJson(boolean lenientOnJson) {
        json.setLenientOnJson(lenientOnJson);
        return this;
    }

    public static JSON getJson() {
        return json;
    }

    /**
     * Get authentications (key: authentication name, value: authentication).
     *
     * @return Map of authentication objects
     */
    public Map<String, Authentication> getAuthentications() {
        return authentications;
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    public Authentication getAuthentication(String authName) {
        return authentications.get(authName);
    }

    /**
     * Helper method to set username for the first HTTP basic authentication.
     *
     * @param username Username
     */
    // public void setUsername(String username) {
    //     for (Authentication auth : authentications.values()) {
    //         if (auth instanceof HttpBasicAuth) {
    //             ((HttpBasicAuth) auth).setUsername(username);
    //             return;
    //         }
    //     }
    //     throw new RuntimeException("No HTTP basic authentication configured!");
    // }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     *
     * @param password Password
     */
    // public void setPassword(String password) {
    //     for (Authentication auth : authentications.values()) {
    //         if (auth instanceof HttpBasicAuth) {
    //             ((HttpBasicAuth) auth).setPassword(password);
    //             return;
    //         }
    //     }
    //     throw new RuntimeException("No HTTP basic authentication configured!");
    // }

    /**
     * Helper method to set API key value for the first API key authentication.
     *
     * @param apiKey API key
     */
    // public void setApiKey(String apiKey) {
    //     for (Authentication auth : authentications.values()) {
    //         if (auth instanceof ApiKeyAuth) {
    //             ((ApiKeyAuth) auth).setApiKey(apiKey);
    //             return;
    //         }
    //     }
    //     throw new RuntimeException("No API key authentication configured!");
    // }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     *
     * @param apiKeyPrefix API key prefix
     */
    // public void setApiKeyPrefix(String apiKeyPrefix) {
    //     for (Authentication auth : authentications.values()) {
    //         if (auth instanceof ApiKeyAuth) {
    //             ((ApiKeyAuth) auth).setApiKeyPrefix(apiKeyPrefix);
    //             return;
    //         }
    //     }
    //     throw new RuntimeException("No API key authentication configured!");
    // }

    /**
     * Helper method to set access token for the first OAuth2 authentication.
     *
     * @param accessToken Access token
     */
    public void setAccessToken(String accessToken) {
        throw new RuntimeException("No OAuth2 authentication configured!");
    }


    /**
     * Check that whether debugging is enabled for this API client.
     *
     * @return True if debugging is enabled, false otherwise.
     */
    public static boolean isDebugging() {
        return debugging;
    }

    /**
     * Enable/disable debugging for this API client.
     *
     * @param debugging To enable (true) or disable (false) debugging
     * @return Configuration
     */
    public Configuration setDebugging(boolean debugging) {
        if (debugging != Configuration.debugging) {
            if (debugging) {
                loggingInterceptor = new HttpLoggingInterceptor();
                loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
                httpClient = httpClient.newBuilder().addInterceptor(loggingInterceptor).build();
            } else {
                httpClient.interceptors().remove(loggingInterceptor);
                loggingInterceptor = null;
            }
        }
        Configuration.debugging = debugging;
        return this;
    }

    /**
     * The path of temporary folder used to store downloaded files from endpoints
     * with file response. The default value is <code>null</code>, i.e. using
     * the system's default tempopary folder.
     *
     * @return Temporary folder path
     * @see <a href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html#createTempFile">createTempFile</a>
     */
    public String getTempFolderPath() {
        return tempFolderPath;
    }

    /**
     * Set the temporary folder path (for downloading files)
     *
     * @param tempFolderPath Temporary folder path
     * @return Configuration
     */
    public Configuration setTempFolderPath(String tempFolderPath) {
        this.tempFolderPath = tempFolderPath;
        return this;
    }

    /**
     * Get connection timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getConnectTimeout() {
        return httpClient.connectTimeoutMillis();
    }

    /**
     * Sets the connect timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link Integer#MAX_VALUE}.
     *
     * @param connectionTimeout connection timeout in milliseconds
     * @return Api client
     */
    public Configuration setConnectTimeout(int connectionTimeout) {
        httpClient = httpClient.newBuilder().connectTimeout(connectionTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get read timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getReadTimeout() {
        return httpClient.readTimeoutMillis();
    }

    /**
     * Sets the read timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link Integer#MAX_VALUE}.
     *
     * @param readTimeout read timeout in milliseconds
     * @return Api client
     */
    public Configuration setReadTimeout(int readTimeout) {
        httpClient = httpClient.newBuilder().readTimeout(readTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }

    /**
     * Get write timeout (in milliseconds).
     *
     * @return Timeout in milliseconds
     */
    public int getWriteTimeout() {
        return httpClient.writeTimeoutMillis();
    }

    /**
     * Sets the write timeout (in milliseconds).
     * A value of 0 means no timeout, otherwise values must be between 1 and
     * {@link Integer#MAX_VALUE}.
     *
     * @param writeTimeout connection timeout in milliseconds
     * @return Api client
     */
    public Configuration setWriteTimeout(int writeTimeout) {
        httpClient = httpClient.newBuilder().writeTimeout(writeTimeout, TimeUnit.MILLISECONDS).build();
        return this;
    }


    /**
     * Sanitize filename by removing path.
     * e.g. ../../sun.gif becomes sun.gif
     *
     * @param filename The filename to be sanitized
     * @return The sanitized filename
     */
    public String sanitizeFilename(String filename) {
        return filename.replaceAll(".*[/\\\\]", "");
    }

    /**
     * Download file from the given response.
     *
     * @param response An instance of the Response object
     * @return Downloaded file
     * @throws ApiException If fail to read file content from response and write to disk
     */
    public File downloadFileFromResponse(Response response) throws ApiException {
        try {
            File file = prepareDownloadFile(response);
            BufferedSink sink = Okio.buffer(Okio.sink(file));
            sink.writeAll(response.body().source());
            sink.close();
            return file;
        } catch (IOException e) {
            throw new ApiException(e);
        }
    }

    private static String reg = "filename=['\"]?([^'\"\\s]+)['\"]?";

    /**
     * Prepare file for download
     *
     * @param response An instance of the Response object
     * @return Prepared file for the download
     * @throws IOException If fail to prepare file for download
     */
    public File prepareDownloadFile(Response response) throws IOException {
        String filename = null;
        String contentDisposition = response.header("Content-Disposition");
        if (contentDisposition != null && !"".equals(contentDisposition)) {
            // Get filename from the Content-Disposition header.
            Pattern pattern = Pattern.compile(reg);
            Matcher matcher = pattern.matcher(contentDisposition);
            if (matcher.find()) {
                filename = sanitizeFilename(matcher.group(1));
            }
        }

        String prefix = null;
        String suffix = null;
        if (filename == null) {
            prefix = "download-";
            suffix = "";
        } else {
            int pos = filename.lastIndexOf(".");
            if (pos == -1) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // File.createTempFile requires the prefix to be at least three characters long
            if (prefix.length() < 3) {
                prefix = "download-";
            }
        }

        if (tempFolderPath == null) {
            return File.createTempFile(prefix, suffix);
        } else {
            return File.createTempFile(prefix, suffix, new File(tempFolderPath));
        }
    }

    /**
     * Get network interceptor to add it to the httpClient to track download progress for
     * async requests.
     */
    private Interceptor getProgressInterceptor() {
        return new Interceptor() {
            @Override
            public Response intercept(Chain chain) throws IOException {
                final Request request = chain.request();
                final Response originalResponse = chain.proceed(request);
                if (request.tag() instanceof ApiCallback) {
                    final ApiCallback callback = (ApiCallback) request.tag();
                    return originalResponse.newBuilder()
                            .body(new ProgressResponseBody(originalResponse.body(), callback))
                            .build();
                }
                return originalResponse;
            }
        };
    }

    /**
     * Apply SSL related settings to httpClient according to the current values of
     * verifyingSsl and sslCaCert.
     */
    private void applySslSettings() {
        try {
            TrustManager[] trustManagers = null;
            HostnameVerifier hostnameVerifier = null;

            if (!verifyingSsl) {
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            } else {
                hostnameVerifier = new HostnameVerifier() {
                    @Override
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                };
            }

            if (sslCaCert != null) {
                // Any password will work.
                char[] password = null;
                CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
                Collection<? extends Certificate> certificates = certificateFactory.generateCertificates(sslCaCert);
                if (certificates.isEmpty()) {
                    throw new IllegalArgumentException("expected non-empty set of trusted certificates");
                }
                KeyStore caKeyStore = newEmptyKeyStore(password);
                int index = 0;
                for (Certificate certificate : certificates) {
                    String certificateAlias = "ca" + Integer.toString(index++);
                    caKeyStore.setCertificateEntry(certificateAlias, certificate);
                }
                TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                trustManagerFactory.init(caKeyStore);
                trustManagers = trustManagerFactory.getTrustManagers();
            }

            if (keyManagers != null) {
                SSLContext sslContext = SSLContext.getInstance("TLS");
                if (trustManagers != null) {
                    sslContext.init(keyManagers, trustManagers, new SecureRandom());
                    httpClient = httpClient.newBuilder().sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagers[0]).build();
                } else {
                    sslContext.init(keyManagers, null, new SecureRandom());
                    httpClient = httpClient.newBuilder().sslSocketFactory(sslContext.getSocketFactory()).build();
                }
            } else {
                httpClient = httpClient.newBuilder().build();
            }

            httpClient = httpClient.newBuilder().hostnameVerifier(hostnameVerifier).build();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
        try {
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, password);
            return keyStore;
        } catch (IOException e) {
            throw new AssertionError(e);
        }
    }

    public static void setDefaultEnvironment(Environment environment) {
        for (ResourceConfigInterface resourceConfig : registeredInstances.values()) {
            resourceConfig.setEnvironment(environment);
        }
        defaultEnvironment = environment;
    }

    public static Environment getDefaultEnvironment() {
        return defaultEnvironment;
    }

    /**
     * @param resource
     */
    public static void registerResourceConfig(ResourceConfigInterface resource) {
        String className = resource.getClass().getName();
        if (!registeredInstances.containsKey(className)) {
            registeredInstances.put(className, resource);
        }
    }
}
